<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="../lens-data-table/lens-data-table.html"> -->
<link rel="import" href="../lenses-component-list/lenses-component-list.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../iron-selector/iron-selector.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">

<link rel="import" href="../lenses-ui-dialog/lenses-ui-dialog.html">

  <link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<dom-module id="lenses-freeform">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */
    [layout] {
      @apply(--layout);
    }
    [layout][horizontal] {
      @apply(--layout-horizontal);
    }
    [layout][end-justified] {
      @apply(--layout-end-justified);
    }
  </style>
  <link rel="import" type="css" href="lenses-freeform.css">
  <template>

    <div class="settings-slideout slideout right">

      <span class="slideout-handle">settings</span>
      <div class="slideout-inner">

        <paper-icon-button id="showDataBtn" class="active" icon="view-module" on-click="showDataBtn" alt="show component data">
          <span>show component input/output</span>
        </paper-icon-button>
  
       <!--
        <core-icon-button id="saveBtn" icon="save" on-click="{{showSaveDialog}}" alt="save">
        </core-icon-button>
      -->
      </div>
    </div>


    <div class="zoom-slideout slideout left">
      <span class="slideout-handle">zoom</span>
      <div class="slideout-inner">
        <div id="zoomOptions">
          <iron-icon-button id="zoomInBtn" class="" icon="add" on-click="zoomIn">
          </iron-icon-button>
          <br>
          <input is="iron-input" id="zoomRange" type="range" value="{{_zoom::input}}" min="{{_zoomMin}}" max="{{_zoomMax}}" step="{{_zoomStep}}" style="width:25px" list="zoomsettings">
          
          <datalist id="zoomsettings">
            <option>1</option>
            <option>0.8</option>
            <option>0.6</option>
          </datalist>
          <br>
          <iron-icon-button id="zoomOutBtn" icon="remove" on-click="zoomOut">
          </iron-icon-button>
        </div>
      </div>
    </div>

    <div class="component-slideout slideout right">
      <span class="slideout-handle">components</span>
      <div class="slideout-inner">
        <label class="label">Drag components into canvas:</label>
        <lenses-component-list id="component_list"></lenses-component-list>
      </div>
    </div>

    <div class="output-slideout slideout right">
      <span class="slideout-handle">output components</span>
      <div class="slideout-inner">


        <label class="label">Select output component:</label>

        <template is="dom-if" if="{{computeElementsEmpty()}}" restamp="true">
          <div>No component in canvas!</div>

        </template> 
        <iron-selector class="output-selector" selected="{{_outputComponents}}" valueattr="label" multi="true">
          <template is="dom-repeat"  items="{{_elements}}" as="el" index-as="index" observe="id">
            <div class="col" label="{{el.id}}">{{el.id}}</div>
          </template> 
        </iron-selector>

      </div>
    </div>

    <!-- Lens Data Table - commenting this out for now 8/10/15 -->
<!--     <div id="input_preview" class$="{{computeClass(_selElement, _showDataTable)}}">
      <template is="dom-if" if="{{computeIf(_selElement, _showDataTable)}}">
        <label>INPUT</label>
        <lens-data-table id="input_table" input="{{_selElement.input}}" class="table" minimal="true"></lens-data-table>
      </template>
    </div> -->

    <div id="container" on-mousedown="clickInContainer" on-drop="droppedInContainer" on-dragover="draggedOverContainer" on-mouseup="dragEndSVG" on-mousemove="dragSVG">
<!--       <svg id="svg" style="z-index:1000;"></svg>
 -->      <svg id="svg"></svg>


      <!-- Components and connector dots --> 

      <template is="dom-repeat" class="render-after-el" items="{{_elements}}" as="el" index-as="index">
      <!-- el is not working ?!?! -->

        <div id="{{computeWrapperId(el)}}" component-id="{{el.id}}" on-click="wrapperClicked" on-dragstart="dragStartWrapper" on-drag="dragWrapper" on-dragend="dragEndWrapper" draggable="true" class$="{{concatClassNames()}}" style$="{{computeWrapperStyles(el)}}">

          <label>{{el.id}}</label>
          <div class="deleteEl" component_id="{{el.id}}" on-click="_deleteElementEvent">X</div>

            
            <div class="connectors-in">
              <!-- Input -->
              
              <ul>
                <template is="dom-repeat" items="{{_checkForInputAttr(index)}}" as="ins">
                     
                    <li on-dragover="dragOverInArrow" on-drop="droppedOnInArrow" on-dragenter="dragEnterInArrow" on-dragleave="dragLeaveInArrow" on-click="arrowClicked" class$="{{computeClassInArrow(el, ins)}}">
                      <div class="inputMarker">
                        <div class="delete" on-click="deleteConnection">x</div>
                        <span class="drop-zone">{{ins}}</span>
                      </div>
                    </li>
                </template>
              </ul>

            </div>
            <!-- Output -->
            <div class="connectors-out">
              <template is="dom-if" if="{{_checkForOutputAttr(index)}}">
                <div id="{{index}}" on-drag="dragOutArrow" on-dragstart="dragOutArrowStart" on-dragend="dragOutArrowEnd" on-click="arrowClicked" draggable="true" class$="{{computeClassOutArrow(el)}}">
                  <div class="outputMarker"></div>
                </div>
              </template>
              
            </div>

            <!-- for components with settings (all non-resizables?) -->
            <template is="dom-if" if="{{!el.resizable}}">

              <iron-icon icon="settings" component-id$="{{el.id}}" on-click="toggleSetting" class="setting-btn"></iron-icon>

            </template>

            <template is="dom-if" if="{{el.resizable}}">
              <div class="resize" draggable="true" style$="{{computeResizeStyle(el)}}" on-dragstart="dragStartResize" on-drag="dragResize" on-dragend="dragResizeEnd"></div>
            </template>
          
        </div>
 
         <!--
         not working. instead move actual element alongside container.
        <template is="dom-if" if="{{computeIfResizable(el)}}">
          <iron-collapse class="settings-collapse" id="{{computeCollapseId(el)}}" opened="true" style$="{{computeCollapseStyle(el)}}">
             <content select="{{computeSelect(el)}}"></content>
          </iron-collapse>
        </template>
        -->
          

      </template>
    </div> 

    <!-- commenting out for now -->
<!--     <div id="output_preview" class$="{{computeClass(_selElement, _showDataTable)}}">
      <template is="dom-if" if="{{computeIf(_selElement, _showDataTable)}}">
        <label>OUTPUT</label>
        <lens-data-table id="output_table" input="{{_selElement.output}}" class="table" minimal="true"></lens-data-table>
      </template>
    </div>        -->

    <lenses-ui-dialog autoclosedisabled="" id="deleteDialog" class="dialog size-position" opened="true">
      <p>Are you sure you want to remove the selected item?</p>
      <div horizontal="" end-justified="" layout="">
        <paper-icon-button icon="clear" dismissive="" on-click="_noDelete"></paper-icon-button>
        <paper-icon-button icon="check" affirmative="" on-click="_yesDelete"></paper-icon-button>
      </paper-icon-button></div>
    </lenses-ui-dialog>

    <!-- Title and Author fields + save action in dialog-->
    <lenses-ui-dialog class="dialog" id="savedetails">
      <h1><paper-input label="Title of Lens" value="{{lensTitle}}"></paper-input></h1>
      <h3><paper-input label="Your Name" value="{{lensAuthor}}"></paper-input></h3>
      <paper-icon-button class="save" affirmative="" icon="check" ng-click="saveLens()" on-click="_saveLens">
      <paper-icon-button class="" dismissive="" icon="clear"></paper-icon-button> 
    </paper-icon-button></lenses-ui-dialog>


  </template>
</dom-module>
<script>
  Polymer({
    is: 'lenses-freeform',
    properties: {
      _connections: {
        type: Array,
        value: function () {
          return [];
        }
      },
      _deleteCallback: { value: null },
      _dragArea: { value: null },
      _elements: {
        type: Array,
        observer: '_elementsChanged',
        notify: true,
        value: function () {
          return [];
        }
      },
      _highlightedConnection: { value: null },
      _hotKeys: {
        type: Object,
        value: function () {
          return {
            '18': false,
            // 18 = option
            '16': false,
            // 16 = shift
            '17': false,
            // 17 = control
            '91': false  // 91 = command
          };
        }
      },
      _makeDragArea: {
        type: Boolean,
        value: false
      },
      _outputComponents: {
        type: Array,
        value: function () {
          return [];
        }
      },
      _selElement: { value: null },
      _selWrappers: {
        type: Array,
        value: function () {
          return [];
        }
      },
      _selectingElByDrag: {
        type: Boolean,
        value: false
      },
      _showDataTable: {
        type: Boolean,
        value: true
      },
      _snapX: {
        type: Number,
        value: 10
      },
      _snapY: {
        type: Number,
        value: 10
      },
      _zoom: {
        type: Number,
        value: 1,
        observer: '_zoomChanged'
      },
      _zoomMax: {
        type: Number,
        value: 1
      },
      _zoomMin: {
        type: Number,
        value: 0.6
      },
      _zoomStep: {
        type: Number,
        value: 0.2
      },
      structure: {
        value: null,
        notify: true,
       /* observer: 'scaffold'*/
      }
    },
    ready: function () {
      this.focus();
      this.tabIndex = 0;

      // for testing:
      window.ff = this;

      // not sure if this event is every being triggered? 9/16
      this.addEventListener('iron-resize', function () {
        console.log('iron resize occured');
        this._drawConnections();
      });
      this.$.zoomRange.value = this._zoom;
    },

    addNewElToLens: function (newElName, _left, _top) {
      var top = _top / this._zoom;
      var left = _left / this._zoom;
      var newEl = document.createElement(newElName);
      this.$.component_list.checkAndImport(newEl, function () {
  
        //TODO redundant code (_processNewElement)
        var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());
        var resizable = info.resizable || info.category === 'visualize';

        if(resizable) {
          newEl.style.width = '250px';
          newEl.style.height = '200px';
          newEl.classList.add('lens-component-resizable');

        }
        newEl.style.top = (resizable? top+5 : top+45)+'px';

        newEl.style.left = left+'px';
        newEl.style.opacity = resizable ? 1 : 0;
        //newEl.style.top = '0px';
        //newEl.style.left = '0px';
        //newEl.style.transform = 'translate('+left+'px, '+(top+45)+'px)';
        newEl.style.position = 'absolute';

        newEl.classList.add('lens-component');

        // Polymer.dom(this.root).appendChild(newEl);
        Polymer.dom(this.$.container).appendChild(newEl);

        this._processNewElement(newEl, top, left);
        this._renderContainerTemplate();
      }.bind(this));
    },
    _renderContainerTemplate: function() {
      if(!this._containerTemplates)
      this._containerTemplates = Polymer.dom(this.root).querySelectorAll('.render-after-el');
      [].forEach.call(this._containerTemplates, function(item) {
        // console.log('rendering', item);
        item.render();
      });
    },
    _processNewElement: function (newEl, top, left) {
      var id = this._generateUniqueId(newEl.tagName.toLowerCase());
      newEl.setAttribute('id', id);

      var elItem = {
        element: newEl,
        id: newEl.id,
        name: newEl.tagName.toLowerCase(),
        top: top,
        left: left
      };
      //trying to use transform instead of top/left
      //transform: 'translate(' + top + 'px, ' + left + 'px)' 
      var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());
      if (info.resizable || info.category === 'visualize') {
        elItem.resizable = true;
        elItem.width = 250;
        elItem.height = 200;
      }

      var newElements = this._elements.slice();
      newElements.push(elItem);
      this.set('_elements', newElements);
    },
    // when delete button is clicked
    _deleteElementEvent: function (e) {
      var self = this;
      var compId = e.target.component_id;
      self._deleteElementById(compId);
    },
    _deleteElementById: function (compId) {
      var self = this;
      var compId = compId;
      console.log(compId);
      ////// temporarily removing the deleteDialog and deleteToggle
      self.$.deleteDialog.toggle();  // set the delete callback

      // // set the delete callback
      self._deleteCallback = function () {
        var embeddedEl = self.querySelector('#' + compId);

        var elInArray = self.findElById(compId);  //remove all connections
        //remove all connections
        self.removeAllConnectionsFromElement(compId);  // remove element from elements array (which removes it from the shadowDOM)

        // remove element from elements array (which removes it from the shadowDOM)
        var filteredEls = self._elements.filter(function (el) {
          return typeof(el.element) != 'undefined' && el.element.id !== compId;
        });

        self.set('_elements', filteredEls);

        // remove elements from lens-connector 
        self.removeChild(embeddedEl);
      };
    },
    removeAllConnectionsFromElement: function (elId) {
      var goodConnections = this._connections.filter(function (conn, index) {
        //filter if element is source or target of a connection
        return !(conn.source.id === elId || conn.target.id === elId);
      });
      this._connections = goodConnections;
      this._drawConnections();
    },
    // if option key was pressed, clone the element when drag is done
    _cloneElement: function (e) {
      var selection = e.target;

      // figure out the name of the element...
      var componentId = selection.componentId;
      var idSplit = componentId.split('-');
      var elNameArray = [];
      var elName = '';
      for (var i = 0; i < idSplit.length; i++) {
        if (isNaN(Number(idSplit[i]))) {
          elNameArray.push(idSplit[i]);
        }
      }
      elName = elNameArray.join('-');
      this.addNewElToLens(elName, e.x, e.y);
      var dx = e.x - (e.toElement.getAttribute('start-x') || 0), dy = e.y - (e.toElement.getAttribute('start-y') || 0);
      console.log(dx, dy);  // if other wrappers were selected, also clone those
      // if other wrappers were selected, also clone those
      for (var i = 0; i < this._selWrappers.length; i++) {
        var target = this._selWrappers[i];
        if (target === e.toElement) {
          return;
        } else {
          var orig = target.getBoundingClientRect();  // find each element's distance from the e.toElement
          // find each element's distance from the e.toElement
          var x = (orig.left + dx) / this._zoom;
          var y = (orig.top + dy) / this._zoom;
          this.addNewElToLens(elName, x, y);
        }
      }
    },
    /********************** Event Handlers Start ********************************/
    draggedOverContainer: function (e) {
      // Needed to enable droppedInContainer
      e.preventDefault();
    },
    droppedInContainer: function (e) {
      var self = this;
      //dont know why this method is being called instead of resizedragend?!

      e.preventDefault();

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      if (e.path && e.path.length > 0 && e.path[0].classList.contains('resize') > 0) {
        self.dragResizeEnd(e);
      }
      var dataTransfer = e.dataTransfer.getData('text/plain');  //data added by lenses-component-list //TODO make better
      //data added by lenses-component-list //TODO make better
      if (dataTransfer && dataTransfer.length > 0) {
        var dataSeg = dataTransfer.split(',');
        if (dataSeg.length == 1) {
          self.addNewElToLens(dataSeg[0], Math.round(e.offsetX / 10) * 10 * self._zoom, Math.round(e.offsetY / 10) * 10 * self._zoom);
          return;
        }
      }
    },
    clickInContainer: function (e) {
      var className = e.toElement.className;
      if (className.baseVal && className.baseVal.indexOf('cnxn') > -1) {
        console.log('clicked on connection');
        this.clickedOnConnection(e);
      } else {
        this._clearHighlightedConnections();
      }  // start drag
      // start drag
      if (e.target.id === 'container') {
        this.dragStartSVG(e);
      }
    },
    clickedOnConnection: function (e) {
      var bezier = Polymer.dom(this.root).querySelector('#' + e.toElement.id);
      console.log(bezier);
      if (String(bezier.classList).indexOf('highlight') > -1) {
        // console.log('delete');
        this._deleteBezier(e, bezier);
      } else {
        // if not highlighted, then highlight
        this._clearHighlightedConnections();
        bezier.classList.add('highlighted');
        this._highlightedConnection = bezier;
      }
    },
    _clearHighlightedConnections: function () {
      if (this._highlightedConnection) {
        this._highlightedConnection.classList.remove('highlighted');
        this._highlightedConnection = null;
      }
    },
    // clear all _selWrappers and _selElement
    _clearSelElement: function () {
      if (this._selWrappers) {
        for (var i in this._selWrappers) {
          this._selWrappers[i].classList.remove('selected-element');
        }
      }
      this._selWrappers = [];
      this._selElement = null;
    },
    dragStartResize: function (e) {
      e.stopPropagation();
    },
    dragResize: function (e) {
      var self = this;
      var wrapper = e.target.parentNode;
      // var wrapper = selection.parentNode;  //var styles = window.getComputedStyle(wrapper);
                                           // var wrapperTop = parseInt(styles.top.replace('px',''));
                                           // var wrapperLeft = parseInt(styles.left.replace('px',''));
                                           // var w =  e.x - wrapperLeft - 65,
                                           //     h = e.y - wrapperTop - 172;
      //var styles = window.getComputedStyle(wrapper);
      // var wrapperTop = parseInt(styles.top.replace('px',''));
      // var wrapperLeft = parseInt(styles.left.replace('px',''));
      // var w =  e.x - wrapperLeft - 65,
      //     h = e.y - wrapperTop - 172;
      
      // on last call e.x and e.y are zero.     
      if(e.x === 0 && e.y === 0) {
        return;
      }

      var wrapperTop = parseInt(wrapper.getBoundingClientRect().top), wrapperLeft = parseInt(wrapper.getBoundingClientRect().left);
      var w = e.x / this._zoom - wrapperLeft, h = e.y / this._zoom - wrapperTop;


      var elementInsideId = wrapper.componentId;
      var elementInside = this.querySelector('#' + elementInsideId);
      var element = this.findElById(elementInsideId);

      // resize the actual element:
        // should resize snap?
        // var newW = Math.round(w / self._snapX) * self._snapX;
        // var newH = Math.round(h / self._snapY) * self._snapY;
      element.element.style.width = (w) + 'px';
      element.element.style.height = (h) + 'px';

      // also resize the wrapper element
      wrapper.style.width = w + 'px';
      wrapper.style.height = h + 'px';

      // also move the drag handle
      var newTransX = w - parseInt(e.target.style.left) + 5;
      var newTransY = h - parseInt(e.target.style.top) + 5;
      var newTrans = 'transform: translate(' + newTransX +'px, ' + newTransY + 'px);';
      var keepTop = e.target.style.top;
      var keepLeft = e.target.style.left;
      e.target.setAttribute('style', 'top: ' + keepTop +'; left: ' + keepLeft + '; ' + newTrans);
      e.target.style.left = (e.x - wrapperLeft);
      e.target.style.top = (e.y - wrapperTop)

      self._drawConnections();
      e.stopPropagation();
      e.preventDefault();
    },
    dragResizeEnd: function (e) {
      var wrapper = null;

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      if (e.path && e.path.length > 0 && e.path[0].classList.contains('resize') > 0) {
        wrapper = e.path[0].parentNode;
      }
      var elementInsideId = wrapper.id.replace('wrapper-', '');
      var elementInside = this.querySelector('#' + elementInsideId);
      if (typeof elementInside.resize === 'function') {
        elementInside.resize();
      }
    },
    // _dragClone: function(e, details, selection) {
    //   // TO Do
    //   console.log(e.target);
    // },
    dragStartWrapper: function (e) {
      var target = e.target;  // make this the _selElement and _selWrapper
      // make this the _selElement and _selWrapper
      this.wrapperClicked(e);  // set start-x and start-y for all _selWrappers
      // set start-x and start-y for all _selWrappers
      for (var i = 0; i < this._selWrappers.length; i++) {
        var wrapper = this._selWrappers[i];
        this._setWrapperDragStartingPoint(wrapper, e.x, e.y);
      }
      if (this._hotKeys['18']) {
        // start dragging a clone
        this._draggingClone = true;
        return;
      }
      var dragImgEl = document.querySelector('#wrapper-drag-img');
      if (!dragImgEl) {
        dragImgEl = document.createElement('span');
        dragImgEl.setAttribute('style', 'opacity: 0;');
        dragImgEl.id = 'wrapper-drag-img';
        dragImgEl.textContent = 'a';
        document.body.appendChild(dragImgEl);
      }  //keep dragImage outside the canvas
      //keep dragImage outside the canvas
      e.dataTransfer.setDragImage(dragImgEl, -2000, -2000);
    },
    // set starting position of a drag for any target, not based on an event. Called by dragStartWrapper
    _setWrapperDragStartingPoint: function (target, x, y) {
      target.setAttribute('start-x', x);
      target.setAttribute('start-y', y);
    },
    dragWrapper: function (e) {
      if (this._hotKeys['18']) {
        // dragging a clone
        return;
      }

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      if (e.path[0].classList && e.path[0].classList.length > 0 && (e.path[0].classList.contains('resize') || e.path[0].classList.contains('arrow'))) {
        return false;
      }
      var target = e.target;
      for (var i = 0; i < this._selWrappers.length; i++) {
        var wrapper = this._selWrappers[i];
        var dx = e.x / this._zoom - (wrapper.getAttribute('start-x') / this._zoom || 0), dy = e.y / this._zoom - (wrapper.getAttribute('start-y') / this._zoom || 0);
        this._updateWrapperLocation(e, wrapper, dx, dy);
      }
      this._drawConnections();
    },
    _updateWrapperLocation: function (e, target, dx, dy) {
      // keep the dragged position in the data-x/data-y attributes, add snap residue from previous drag
      var x = (parseFloat(target.getAttribute('data-x')) || 0) + dx + (parseFloat(target.getAttribute('residue-x')) || 0);
      var y = (parseFloat(target.getAttribute('data-y')) || 0) + dy + (parseFloat(target.getAttribute('residue-y')) || 0);
      var sx = Math.round(x / this._snapX) * this._snapX;
      var sy = Math.round(y / this._snapY) * this._snapY;
      target.setAttribute('residue-x', x - sx);
      target.setAttribute('residue-y', y - sy);  // translate the element. 
                                                 // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      // translate the element. 
      // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      if (e.x !== 0 || e.y !== 0) {

        // store transform for the udpateStyle method
        var componentId = e.target.componentId; //('component-id');
        var componentInfo = this.findElById(componentId);
        componentInfo.transform = 'translate(' + sx + 'px, ' + sy + 'px)';

        // update the position attributes, and transform to actually move the element
        target.style.transform = 'translate(' + sx + 'px, ' + sy + 'px)';

        //update component as well since <content> is not working.
        //var componentId = target.componentId;
        //var componentDom = Polymer.dom(this).querySelector('#'+componentId);
        componentInfo.element.style.transform = 'translate('+sx+'px, '+(sy)+'px)';


        target.setAttribute('data-x', sx);
        target.setAttribute('data-y', sy);
        target.setAttribute('start-x', e.x);
        target.setAttribute('start-y', e.y);
      }
      this._renderContainerTemplate();
    },
    dragEndWrapper: function (e) {
      // console.log('done dragging!');
      if (this._draggingClone) {
        this._draggingClone = false;
        this._cloneElement(e);
        return;
      }  //if resize is being dragged don't do anything (stopPropagation is not doing anything)
      //if resize is being dragged don't do anything (stopPropagation is not doing anything)
      var target = e.target;
      target.setAttribute('residue-x', 0);
      target.setAttribute('residue-y', 0);
    },
    wrapperClicked: function (e) {
      var wrapperEl = e.currentTarget;
      var elementId = wrapperEl.id;
      elementId = elementId.substring(8, elementId.length);
      var el = this.findElById(elementId).element;
      if (this._selElement != el) {
        // unhighlight other selected element if this was not one of them
        if (wrapperEl.classList.contains('selected-element')) {
          console.log('already selected');
        } else {
          this._clearSelElement();
          console.log('not already selected');
        }
        this._selElement = el;
      }
      if (this._selWrappers.indexOf(wrapperEl) === -1) {
        wrapperEl.classList.add('selected-element');
        this._selWrappers.push(wrapperEl);
      }
    },
    // SVG drag events, also called on mousedown
    dragStartSVG: function (e) {
      // clear this._selWrappers [TO DO: unless Shift is clicked]
      this._selWrappers = [];
      this._makeDragArea = true;
      this._selectingElByDrag = false;
      this._dragArea = this._createDragArea(e);
      this.$.svg.insertBefore(this._dragArea, this.$.svg.firstChild);
    },
    // called when makeDragArea is true
    dragSVG: function (e) {
      if (this._makeDragArea) {
        this._updateDragArea(e, this._dragArea);
      }
    },
    // also called on mouseup
    dragEndSVG: function (e) {
      if (!this._dragArea) {
        return;
      }  // remember the old sel el
      // remember the old sel el
      var oldSelElement = this._selElement;  // dimension of the rectangle:
      // dimension of the rectangle:
      var dragRect = this._dragArea.getBoundingClientRect();  // find any elements that intersect with the drag area, sort out which are _selElement and _selWrappers
      // find any elements that intersect with the drag area, sort out which are _selElement and _selWrappers
      for (var i in this._elements) {
        var el = this._elements[i];
        var wrapperEl = Polymer.dom(this.root).querySelector('#wrapper-' + el.id);  // get element dimensions
        // get element dimensions
        var elRect = wrapperEl.getBoundingClientRect();  // compare and if there is overlap, add class
        // compare and if there is overlap, add class
        var overlap = this._boundingRectOverlap(elRect, dragRect);
        if (overlap) {
          // select elements that overlap
          if (this._selWrappers.indexOf(wrapperEl) < 0) {
            this._selWrappers.push(wrapperEl);
          }
          wrapperEl.classList.add('selected-element');  // remember selected element if it overlaps
          // remember selected element if it overlaps
          if (el.element === oldSelElement) {
            this._selElement = el.element;
          }
        } else {
          // otherwise remove selection
          if (wrapperEl.classList.contains('selected-element')) {
            wrapperEl.classList.remove('selected-element');
          }
          if (this._selElement === el.element) {
            this._selElement = null;
          }
        }
      }
      this._clearDragArea();
    },
    // helper method
    _boundingRectOverlap: function (rect1, rect2) {
      var overlap = !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
      return overlap;
    },
    // handle selecting elements by their wrapper during drag
    dragOverWrapper: function (e) {
    // if (this._makeDragArea) {
    //   if (!this._selectingElByDrag) {
    //     this._selectingElByDrag = true;
    //   }
    //   console.log('drag over: ' + e.target.id);
    // }
    },
    // create a rectangle to show drag area
    _createDragArea: function (e) {
      var x = e.x / this._zoom, y = e.y / this._zoom;
      var svgns = 'http://www.w3.org/2000/svg';
      var rect = document.createElementNS(svgns, 'rect');
      rect.setAttributeNS(null, 'opacity', 0.2);
      rect.setAttributeNS(null, 'x', x);
      rect.setAttributeNS(null, 'y', y);
      rect.setAttributeNS(null, 'width', '0');
      rect.setAttributeNS(null, 'height', '0');
      rect.setAttributeNS(null, 'fill', '#D1D1D1');
      rect.startX = x;
      rect.startY = y;
      return rect;
    },
    // update drag rectangle
    _updateDragArea: function (e, rect) {
      var svgns = 'http://www.w3.org/2000/svg';
      var startX = rect.startX;
      var startY = rect.startY;
      var deltaX = e.x / this._zoom - startX;
      var deltaY = e.y / this._zoom - startY;
      if (deltaX < 0) {
        rect.setAttributeNS(null, 'x', startX + deltaX);
        deltaX = Math.abs(deltaX);
      }
      if (deltaY < 0) {
        rect.setAttributeNS(null, 'y', startY + deltaY);
        deltaY = Math.abs(deltaY);
      }
      rect.setAttributeNS(null, 'width', deltaX);
      rect.setAttributeNS(null, 'height', deltaY);
    },
    _clearDragArea: function () {
      if (this._dragArea) {
        this.$.svg.removeChild(this._dragArea);
      }
      this._makeDragArea = false;
      this._dragArea = null;  //this.$.svg.innerHTML = '';
    },
    //this.$.svg.innerHTML = '';
    dragOutArrowStart: function (e) {
      this.draggedEl = e.target;  //to stop wrapper drag to be called
      //to stop wrapper drag to be called
      e.stopPropagation();
      if (!this.svgTop || !this.svgLeft) {
        var svgRect = this.$.svg.getBoundingClientRect();
        this.svgTop = svgRect.top;
        this.svgLeft = svgRect.left;
      }
      this.startPointX = e.x / this._zoom - this.svgLeft;
      this.startPointY = e.y / this._zoom - this.svgTop;  // create temp bezier
      // create temp bezier
      
      //TODO cache
      //var tempPath = Polymer.dom(this.root).querySelector('#temp_path');
      
      console.log('points', this.startPointX, this.startPointY, this.tempPath);
      
      if (!this.tempPath) {

        this._addBezierPath(this.startPointX, this.startPointY, this.startPointX, this.startPointY, 70, 'temp_path');  
        this.tempPath = Polymer.dom(this.root).querySelector('#temp_path');
      }
      else {
          this.tempPath.style.display = 'block';

      }
    },
    //this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70, 'temp_path');
    dragOutArrow: function (e) {

      //TODO cache
      //var tempPath = Polymer.dom(this.root).querySelector('#temp_path');  // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
      if (e.x !== 0 || e.y !== 0) {
        var newPath = this._calculateBezierPath(this.startPointX, this.startPointY, e.x / this._zoom - this.svgLeft, e.y / this._zoom - this.svgTop, 70);
        this.tempPath.setAttribute('d', newPath);
      }
    },
    dragOutArrowEnd: function (e) {
      
        // remove method is not working for tempPath when using Polumer.dom...querySelector useing document.querySelector instead
       
      //var tempPath = Polymer.dom(this.root).querySelector('#temp_path');
      if (this.tempPath) {
        this.tempPath.style.display = 'none';
        //tempPath.remove();
      }
      
     /*
      var tempPath = document.querySelector('#temp_path');
      if (tempPath) {
        tempPath.style.display = 'none';
        //tempPath.remove();
      }
      */


    },
    dragOverInArrow: function (e) {
      //important! needed to allow drop
      e.preventDefault();
    },
    dragEnterInArrow: function (e) {
      e.target.classList.add('drag-over');
    },
    dragLeaveInArrow: function (e) {
      e.target.classList.remove('drag-over');
    },
    droppedOnInArrow: function (e) {
      
      //TODO: depending on classnames is not a safe solution. add componentId or something similar and universal
      
      e.target.classList.remove('drag-over');
      var className = e.target.parentNode.classList[0]; //selection.classList[0],
      var targetElementId = className.substring(0, className.lastIndexOf('-'));
      var targetField = className.substring(className.lastIndexOf('-') + 1, className.length);
      var source = this.findElById(this.draggedEl.classList[0]); 
      var target = this.findElById(targetElementId);
      this._connectAttributes(source, 'output', target, targetField);
      this._drawConnections();
      e.stopPropagation();
    },
    arrowClicked: function (e) {
      //e.stopPropagation();
      var wrapper = null;

      //TODO make a standard uniform way of finding elements. path[0] is ugly 
      for (var i = 0; i < e.path.length && !wrapper; i++) {
        if (e.path[i].classList.contains('wrapper')) {
          wrapper = e.path[i];
        }
      }
      var sourceTarget = e.path[0].classList.contains('inputMarker') ? 'target' : 'source';
      var elementInsideId = wrapper.componentId;  //var elementInside = this.findElById(elementInsideId);
      //var elementInside = this.findElById(elementInsideId);
      var connection = this._connections.filter(function (conn) {
        if (conn[sourceTarget].id === elementInsideId) {
          return true;
        }
      });
      if (connection.length > 0) {
        var marker = e.path[0];
        var bezierCssPath = '#container #svg #' + connection[0].source.id + '-' + connection[0].target.id;
        var bezier = Polymer.dom(this.root).querySelector(bezierCssPath);
        if (connection[0].highlighted) {
          connection[0].highlighted = false;
          marker.classList.remove('highlighted');
          bezier.classList.remove('highlighted');
        } else {
          connection[0].highlighted = true;
          marker.classList.add('highlighted');
          bezier.classList.add('highlighted');
        }
      }
    },
    deleteConnection: function (e) {
      var self = this;
      self.$.deleteDialog.toggle();  // set the delete callback
      // set the delete callback
      self._deleteCallback = function () {
        if (e) {
          e.stopPropagation();
        }
        var elementInsideId;  // figure out the source
        // figure out the source
        var src;
        if (self._highlightedConnection) {
          var splitID = self._highlightedConnection.id.split('-');
          src = splitID[0] + '-' + splitID[1] + '-' + splitID[2];
          console.log(src);
          elementInsideId = splitID[3] + '-' + splitID[4] + '-' + splitID[5];
        } else {
          var wrapper = null;
    
          //TODO make a standard uniform way of finding elements. path[0] is ugly 
          for (var i = 0; i < e.path.length && !wrapper; i++) {
            if (e.path[i].classList.contains('wrapper')) {
              wrapper = e.path[i];
            }
          }
          elementInsideId = wrapper.componentId;
        }
        if (!e) {
          e = undefined;
        }
        self.deleteConnectionByID(e, elementInsideId);
      };
    },
    _deleteBezier: function (e, bezier) {
      var srcId, dstId;
      var self = this;
      self.$.deleteDialog.toggle();  // set the delete callback
      // set the delete callback
      self._deleteCallback = function () {
        var idSplit = bezier.id.split('-');  // split ID at number to determine srcId and dstId
        // split ID at number to determine srcId and dstId
        var i = 0;
        while (isNaN(Number(idSplit[i]))) {
          i++;
        }
        dstId = idSplit.slice(i + 1).join('-');
        srcId = idSplit.slice(0, i).join('-');
        self.deleteConnectionByID(e, dstId);
        self._clearHighlightedConnections();
      };
    },
    deleteConnectionByID: function (e, dstId) {
      this._connections = this._connections.filter(function (connection) {
        return connection.target.id !== dstId;
      });
      console.log(this._connections);
      if (e) {
        var marker = e.path[1];
        marker.classList.remove('highlighted');
      }
      this._drawConnections();
    },
    toggleSetting: function (e) {
      var button = e.target, componentId = button['component-id'], elementInfo = this.findElById(componentId);
      button.toggleClass('open');
      elementInfo.settingOpen = elementInfo.settingOpen ? false : true;
      if(elementInfo.settingOpen) {
        elementInfo.element.style.opacity = 1;
      }
      else {
        elementInfo.element.style.opacity = 0;

      }
    },
    keydownHandler: function (e) {
      var self = this;

      // prevent backspace acting as browser back button
      // via http://stackoverflow.com/a/2768256/2994108
      var doPrevent = false;
      if (e.keyCode == 8) {
        var rx = /INPUT|SELECT|TEXTAREA/i;

        var d = e.srcElement || e.target;
        if (rx.test(d.tagName.toUpperCase() )) {
          doPrevent = d.readOnly || d.disabled;
        } else {
          doPrevent = true;
        }
      }
      if (doPrevent) {
        e.preventDefault();
      }

      switch (e.keyCode) {
      // if deleteKey:
      case 8:
        if (!doPrevent) return;

        // if bezier was selected, delete that. Otherwise, delete element
        if (self._highlightedConnection) {
          self._deleteBezier(e, self._highlightedConnection);
        } else if (self._selWrappers.length > 0) {
          for (var i = 0; i < self._selWrappers.length; i++) {
            var _id = self._selWrappers[i].componentId;
            self._deleteElementById(_id);
          }
        }
        e.stopPropagation();
        break;  // zoom with -_ (189) and += (187)
      // zoom with -_ (189) and += (187)
      case 189:
        self.zoomOut();
        break;
      case 187:
        self.zoomIn();
        break;
      default:
        if (typeof self._hotKeys[e.which] !== 'undefined') {
          self._hotKeys[e.which] = true;
        }
        break;
      }
    },
    keyupHandler: function (e) {
      var self = this;
      if (self._hotKeys[e.which]) {
        self._hotKeys[e.which] = false;
      }
    },
    mouseoutHandler: function (e) {
      this._clearDragArea();
    },
    /********************** Event Handlers End ********************************/
    showDataBtn: function () {
      this._showDataTable = !this._showDataTable;
      this.$.showDataBtn.classList.toggle('active');
      [].forEach.call(Polymer.dom(this.root).querySelectorAll('.data-preview'), function (el) {
        el.style.maxHeight = el.style.maxHeight == '0px' ? '100px' : '0px';
      });
    },
    showSaveDialog: function () {
      this.$.savedetails.toggle();
    },
    /**
     * The functions which sets the connection (two way binging) between two element attrubutes
     * There is not really a sourc/target distinction in the observer since it is a two way binging (in theory)
     * but the distinction is conceptual and in UI.
     * @param  {[type]} source      Source element
     * @param  {[type]} sourceField The attribute to connect from source element
     * @param  {[type]} target      Target element
     * @param  {[type]} targetField The attribute to connect from target element
     * @return {None}             
     */
    _connectAttributes: function (source, sourceField, target, targetField) {
      var self = this;  //find the index of connection which has the same target
      //find the index of connection which has the same target
      
      var listener = null;

      var connWithSameTargetIndex = self._connections.reduce(function (value, conn, index) {
        if (conn.target.id === target.id && conn.target.field === targetField) {
          return index;
        }
      }, -1);  // and remove it from connections array
      // and remove it from connections array
      if (connWithSameTargetIndex > -1) {
        self._connections.splice(connWithSameTargetIndex, 1);
      }
      if (source === target) {
        //if a bubble was dropped on itself
        alert('You cannot make a connection within the same element');
        return false;
      } else {
        // make the connection in the elements array
        //target.inputConnectedTo = source;  // not needed
        
        /*
          using lens-output-change works for output-input connection. might have better performance than observation
          but not a universal solution. lets try:
         */

        if(sourceField.indexOf('output') == 0 && targetField.indexOf('input') == 0) {
          listener = function(e) {
            console.log(e);

            // find the actual output?
            // var output = target.element.output;

            target.element[targetField] = e.detail;
          }
          source.element.addEventListener('lens-output-changed', listener);
        }
        
        
        /*
        
          //TODO: not working. possible solution: http://stackoverflow.com/questions/30615549/data-binding-in-a-dynamically-inserted-polymer-element
         
        var observer = new PathObserver(source.element, sourceField);
        observer.open(function (newValue, oldValue) {
          target.element[targetField] = newValue;
        });
        */
        var srcClone = {
          id: source.id,
          name: source.name,
          element: source.element
        };
        var targetClone = {
          id: target.id,
          name: target.name,
          element: target.element
        };

        //set data for the first time.
        target.element[targetField] = source.element[sourceField];

        targetClone.field = targetField;  //self.updateConnections();
                                          //push the connections anyways because it will be deleted above.
        //self.updateConnections();
        //push the connections anyways because it will be deleted above.
        self._connections.push({
          source: srcClone,
          target: targetClone,
          listener: listener // reference to listener function
        });
        return true;
      }
    },
    _drawConnections: function () {
      var self = this;
      var arrowOffsetY = 7;
      var arrowOffsetX = 7;
      var bezierCurveX = 70;  // the larger the value the smoother the curve
                              //clear all paths. since it is not done offten it is fine to do it in a not optimized way
      //TODO. dont recreate. below line is WRONG. performance problem when drgging wrapper!
      // the larger the value the smoother the curve
      //clear all paths. since it is not done offten it is fine to do it in a not optimized way
      self.$.svg.innerHTML = '';
      //make tempPath null since it is deleted above by innerHTML=''. TODO fix above and remove this line
      self.tempPath = null;

      for (var i = 0; i < self._connections.length; i++) {
        var conn = self._connections[i];
        var srcEl = conn.source.element || Polymer.dom(self.root).querySelector('#' + conn.source.id);  //TODO do this in initialization method
        //TODO do this in initialization method
        var targetEl = conn.target.element || Polymer.dom(self.root).querySelector('#' + conn.target.id);
        //TODO save if querying for next time.
        
        //TODO move to a better place to set them in the begining
        if (!conn.source.wrapper) {
          console.log('querying wrapper');
          conn.source.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + srcEl.id);
        }
        if (!conn.target.wrapper) {
          conn.target.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + targetEl.id);
        }

        var srcWrapper = conn.source.wrapper; //Polymer.dom(self.root).querySelector('#wrapper-' + srcEl.id);
        var targetWrapper = conn.target.wrapper; //Polymer.dom(self.root).querySelector('#wrapper-' + targetEl.id);
        var srcRect = srcWrapper.getBoundingClientRect();
        var targetRect = targetWrapper.getBoundingClientRect();
        var svgRect = self.$.svg.getBoundingClientRect();
        var otherInputOffset = conn.target.field === 'input' ? 0 : 16;
        var startX = (srcRect.right - svgRect.left + arrowOffsetX) / self._zoom;  //srcRect.left + srcRect.width + 30 - containerOffsetX;
        //srcRect.left + srcRect.width + 30 - containerOffsetX;
        var startY = (srcRect.top - svgRect.top + arrowOffsetY) / self._zoom;
        var endX = (targetRect.left - svgRect.left - arrowOffsetX) / self._zoom;
        var endY = (targetRect.top - svgRect.top + arrowOffsetY + otherInputOffset) / self._zoom;
        self._addBezierPath(startX, startY, endX, endY, bezierCurveX, srcEl.id + '-' + targetEl.id, conn.highlighted);
      }
    },
    scaffold: function () {
      var structure = this.structure;
      if (typeof this.structure === 'string' && this.structure.length > 0) {
        structure = JSON.parse(this.structure);
      }
      if (structure.elements) {
        this.scaffoldFromData(structure.elements, structure.connections, structure.outputComponents);
      }
    },
    /**
     * returns final result component to create viewer
     * @return {Object} e.g {componentName: 'lens-v-z-g-bar-chart-0', componentState: (all state data including input)}
     */
    getFinalResult: function () {
      if (this._outputComponents.length > 0) {
        //TODO: multiple outputComponents
        var component = _.clone(this.findElById(this._outputComponents[0]));  //for viz components save input, for the rest save output
        //for viz components save input, for the rest save output
        if (component.name.indexOf('-viz-') > 0) {
          component.input = component.element.input;
        } else {
          component.output = component.element.output;
        }
        var componentName = component.name;
        var componentState = JSON.stringify(component, this.removeDomObjects);
        return {
          componentName: componentName,
          componentState: componentState
        };
      }
    },
    /**
     * Scaffold a new th-connector from state data. Usage: 
     *  var newConnector = document.createElement('th-connector');
     *  newConnector.scaffoldFromData(elements, connections)
     *  where elements and connections are parsed json files coming form dumpData
     * @param  {Object} elements    elements state data
     * @param  {Object} connections connections
     * @return {None}             
     */
    scaffoldFromData: function (elements, connections, outputComponents) {
      this._elements = elements;
      this._outputComponents = outputComponents;
      elements.forEach(function (el) {
        var alreadyExist = this.querySelector('#' + el.id);
        if (!alreadyExist) {
          var domEl = document.createElement(el.name);
          this.$.component_list.checkAndImport(domEl, function () {
            domEl.style.width = '100%';
            domEl.style.height = '100%';
            domEl.id = el.id;
            if (el.name === 'lens-input-paste') {
              domEl.output = el.output;
            } else {
              Object.keys(domEl.properties).forEach(function (attr) {
                if (attr !== 'input' && attr !== 'output' && el[attr]) {
                  domEl[attr] = el[attr];
                }
              });
            }
            el.element = domEl;
            Polymer.dom(this.root).appendChild(domEl);
          }.bind(this));
        }
      }.bind(this));  //delay to make sure position of elements are final
      //delay to make sure position of elements are final
      setTimeout(function () {
        this.setConnections(connections);
      }.bind(this), 1000);  //newConnector._drawConnections()
    },
    //newConnector._drawConnections()
    setConnections: function (connections) {
      this._connections = connections;
      this._connections.forEach(function (connection) {
        if (!connection.source.element) {
          connection.source.element = Polymer.dom(self.root).querySelector('#' + connection.source.id);
        }
        if (!connection.target.element) {
          connection.target.wrapper = Polymer.dom(self.root).querySelector('#' + connection.target.id);
        }

        if (!connection.source.wrapper) {
          connection.source.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + connection.source.id);
        }
        if (!connection.target.wrapper) {
          connection.target.wrapper = Polymer.dom(self.root).querySelector('#wrapper-' + connection.target.id);
        }

        this._connectAttributes(connection.source, 'output', connection.target, connection.target.field || 'input');
      }.bind(this));
      this._drawConnections();
    },
    dumpData: function () {
      var self = this;
      var toDumpEls = _.map(this._elements, function (el) {
        var domObject = el.element;
        var cloned = _.clone(el);
        Object.keys(domObject.properties).forEach(function (attr) {
          //ignore input attribute and output (except where the component is th-table-data)
          if (attr === 'chartData' || attr.indexOf('input') === 0 || attr === 'output' && el.name !== 'lens-input-paste') {
            return;
          }
          cloned[attr] = domObject[attr];
        });
        return cloned;
      });
      var retObj = {
        elements: toDumpEls,
        connections: this._connections,
        outputComponents: this._outputComponents
      };
      var ret = JSON.stringify(retObj, this.removeDomObjects);  //var connectionsJSON = JSON.stringify(this._connections , this.removeDomObjects);
      //var connectionsJSON = JSON.stringify(this._connections , this.removeDomObjects);
      return ret;
    },
    _saveLens: function () {
      var btn = document.getElementById('saveLensBtn');
      if (typeof btn !== 'undefined') {
        btn.click();
        console.log('btn!');
      } else {
        console.log('no button');
      }
    },
    removeDomObjects: function (key, value) {
      if (value instanceof HTMLElement)
        return undefined;
      else
        return value;
    },

    /**
     *  Find and return a Lens component by ID,
     *  for example ``lens-input-csv-0``. Searches
     *  the _elements array for an object with the ID.
     *  
     *  @method findElById
     *  @param  {String} id ID of the component
     *  @return {Object}    Lens component
     */
    findElById: function (id) {
      var self = this;
      element = self._elements.filter(function (el) {
        return el.id === id;
      })[0];
      return element;
    },
    /**
     * Checks if a componenet has input attributes (any attribute which is named input*)
     * @param  {Object} published Object containing all published attributes
     * @return {Object}           list of attributes that are input.
     */
    _checkForInputAttr: function (index) {
      var published = this._elements[index].element.properties;
      if (!published) {
        return false;
      }
      var attrs = Object.keys(published).filter(function (item) {
        return item.indexOf('input') > -1;
      });
      return attrs;
    },
    /**
     * Checks if a componenet has output attributes.
     * @param  {Object} published Object containing all published attributes
     * @return {boolean}       True if component has output attribute (only one)
     */
    _checkForOutputAttr: function (index) {
      var published = this._elements[index].element.properties;
      if (!published) {
        return false;
      }
      return Object.keys(published).indexOf('output') > -1 ? true : false;
    },
    /**
     * Generates unique ids for components
     * @param  {String} elName Component name
     * @return {[type]}        Unique component id
     */
    _generateUniqueId: function (elName) {
      var self = this;
      var num = 0;
      var tagsWithSameName = self._elements.filter(function (elem) {
        return elem.name == elName;
      });
      if (tagsWithSameName) {
        num += tagsWithSameName.length;
      }
      var uniqueId = elName + '-' + num;
      return uniqueId;
    },
    _calculateBezierPath: function (startX, startY, endX, endY, handleOffsetX) {
      // make handleOffsetX larger when source element is on the right side of target
      if (startX > endX) {
        handleOffsetX *= 2;
      }
      var distance = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));  // decrease handleOffsetX when too close...
      // decrease handleOffsetX when too close...
      if (distance < 100) {
        handleOffsetX /= 2;
      }
      if (distance < 50) {
        handleOffsetX /= 4;
      }
      var path = 'M' + parseInt(startX) + ',' + parseInt(startY) + ' C' + parseInt(startX + handleOffsetX) + ',' + parseInt(startY) + ' ' + parseInt(endX - handleOffsetX) + ',' + parseInt(endY) + ' ' + parseInt(endX) + ',' + parseInt(endY);
      return path;
    },
    _addBezierPath: function (startX, startY, endX, endY, handleOffsetX, id, highlighted) {
      var aLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      var path = this._calculateBezierPath(startX, startY, endX, endY, handleOffsetX);
      aLine.setAttribute('d', path);
      aLine.setAttribute('stroke', '#555');  // conn.source.color);
      // conn.source.color);
      aLine.setAttributeNS(null, 'stroke-width', '5');
      aLine.setAttribute('fill', 'none');
      if (id) {
        aLine.setAttribute('id', id);
      }  // add class "cnxn"
      // add class "cnxn"
      aLine.setAttribute('class', 'cnxn');
      if (highlighted) {
        aLine.classList.add('highlighted');
      }
      Polymer.dom(this.$.svg).appendChild(aLine);
    },
    // zoom either to a specified amount, or add this._zoomStep
    zoomIn: function (amt) {
      if (typeof amt === 'number') {
        this._zoom = amt <= this._zoomMax ? amt : this._zoomMax;
        return;
      }
      if (this._zoom + this._zoomStep <= this._zoomMax) {
        this._zoom += this._zoomStep;
      } else {
        throw 'already zoomed max';
      }
    },
    // zoom either to a specified amount, or subtract this._zoomStep
    zoomOut: function (amt) {
      if (typeof amt === 'number') {
        this._zoom = amt >= this._zoomMin ? amt : this._zoomMin;
        return;
      }
      if (this._zoom - this._zoomStep >= this._zoomMin) {
        this._zoom -= this._zoomStep;
      } else {
        throw 'already zoomed min';
      }
    },
    _zoomChanged: function () {
      this.$.container.style.transform = 'scale(' + this._zoom + ', ' + this._zoom + ')';
    },
    // delete modal
    _noDelete: function () {
      this.$.deleteDialog.close();
    },
    _yesDelete: function () {
      this.$.deleteDialog.close();
      this._deleteCallback();
      this._deleteCallback = null;
    },
    listeners: {
      keydown: 'keydownHandler',
      keyup: 'keyupHandler',
      mouseout: 'mouseoutHandler'
    },
    // compute
    computeElementsEmpty: function() {
      //console.log('compute eq 0' , _elements, this._elements);
      return !this._elements || this._elements.length === 0;
    },

    computeElementId: function(index) {
      return this._elements[index].id;
    },

    computeLengthEqualsZero: function(item) {
      return item.length === 0;
    },
    computeWrapperId: function (el) {
      //console.log('id', el, el.id);
      return 'wrapper-' + el.id;
    },

    computeWrapperStyles: function (el) {
      return 'top: ' + el.top + 'px; left: ' + el.left + 'px; transform: ' + el.transform + '; width: ' + (el.resizable ? 0 : el.width) + 'px; height: ' + (el.resizable ? 0 : el.height) + 'px';
    },

    computeWrapperClass: function (el) {
      return 'wrapper ' + el.name;
    },

    computeCollapseId: function (el) {
      return 'collapse-' + el.id;
    },

    computeResizeStyle: function(el) {
      return 'top: ' + (el.height + 10) + 'px; left: ' + (el.width + 10) + 'px; transform: translate(0px, 0px);';
    },


    computeLengthGreaterThanZero: function(item) {
      return item.length > 0;
    },


    computeClass: function (_selElement, _showDataTable) {
      return 'data-preview ' + this.tokenList({ visible: _showDataTable && _selElement.input && _selElement.input.length > 0 });
    },

    computeIfInput: function (_selElement, _showDataTable) {
      return _showDataTable && _selElement.input && _selElement.input.length > 0;
    },

    computeIfOutput: function (_selElement, _showDataTable) {
      return _showDataTable && _selElement.output && _selElement.output.length > 0;
    },

    computeIfResizable: function (el) {
      return !el.resizable;
    },
    computeClassInArrow: function (el, ins) {
      return el.element.id + '-' + ins + ' arrow in-arrow';
    },

    computeSelect: function (el) {
      return '#' + el.id;
    },
    computeClassOutArrow: function (el) {
      return el.element.id + ' arrow out-arrow';
    },

    // to do: update style values
    computeCollapseStyle: function (el) {
      return 'top: ' + (el.top + 35) + 'px; left: ' + el.left + 'px; width: 200px; height: 100px';
      //return 'top: ' + (el.top + 35) + 'px; left: ' + el.left + 'px;';//+ ' transform: ' + el.transform + '; width: ' + el.width + 'px; height: ' + el.height + 'px';
    },
    computeIsOpen: function(el) {
      return el.settingOpen===true ? true : false;
    },
    concatClassNames: function() {
      return 'wrapper';//arguments.join(' ');
    },
    _elementsChanged: function() {
      console.log('elements changed!');
    }

  });
</script>
